-------------------- Tables --------------------

-- Barrels
create table
  public.barrel_constants (
    id bigint generated by default as identity not null,
    broke_value bigint null,
    budget_multiplier numeric null,
    min_barrel_proportion numeric null,
    starter_potion integer[] null,
    constraint barrel_constants_pkey primary key (id)
  ) tablespace pg_default;

create table
  public.barrel_ledger (
    id bigint generated by default as identity not null,
    transaction_date timestamp with time zone not null default now(),
    transaction_type text not null,
    transaction_id bigint null,
    red bigint not null default '0'::bigint,
    green bigint not null default '0'::bigint,
    blue bigint not null default '0'::bigint,
    dark bigint not null default '0'::bigint,
    constraint barrel_ledger_pkey primary key (id),
    constraint barrel_ledger_transaction_type_check check (
      (
        transaction_type = any (
          array[
            'barrels purchased'::text,
            'potions bottled'::text
          ]
        )
      )
    )
  ) tablespace pg_default;

-- Capacity
create table
  public.capacity_constants (
    id bigint generated by default as identity not null,
    max_potion_capacity bigint null,
    max_ml_capacity bigint null,
    budget_multiplier numeric null,
    capacity_proportion numeric null,
    constraint capacity_constants_pkey primary key (id)
  ) tablespace pg_default;

create table
  public.capacity_ledger (
    id bigint generated by default as identity not null,
    transaction_date timestamp with time zone not null default now(),
    potions bigint not null default '0'::bigint,
    ml bigint not null default '0'::bigint,
    constraint capacity_ledger_pkey primary key (id)
  ) tablespace pg_default;

-- Potions
create table
  public.potions (
    sku text not null,
    name text not null default 'Unnamed Potion'::text,
    red integer generated always as (
      (
        "substring" (sku, 'RGBD_([0-9]+)_[0-9]+_[0-9]+_[0-9]+'::text)
      )::integer
    ) stored null,
    green integer generated always as (
      (
        "substring" (sku, 'RGBD_[0-9]+_([0-9]+)_[0-9]+_[0-9]+'::text)
      )::integer
    ) stored null,
    blue integer generated always as (
      (
        "substring" (sku, 'RGBD_[0-9]+_[0-9]+_([0-9]+)_[0-9]+'::text)
      )::integer
    ) stored null,
    dark integer generated always as (
      (
        "substring" (sku, 'RGBD_[0-9]+_[0-9]+_[0-9]+_([0-9]+)'::text)
      )::integer
    ) stored null,
    price bigint null default '45'::bigint,
    constraint potions_pkey primary key (sku),
    constraint potions_check check (((((red + green) + blue) + dark) = 100))
  ) tablespace pg_default;
create table
  public.potion_ledger (
    id bigint generated by default as identity not null,
    transaction_date timestamp with time zone not null default now(),
    transaction_type text not null,
    transaction_id bigint null,
    potion_sku text not null,
    quantity bigint not null default '0'::bigint,
    constraint potion_ledger_pkey primary key (id),
    constraint potion_ledger_potion_sku_fkey foreign key (potion_sku) references potions (sku) on update cascade on delete restrict,
    constraint potion_ledger_transaction_type_check check (
      (
        transaction_type = any (array['bottled'::text, 'sold'::text])
      )
    )
  ) tablespace pg_default;



create table
  public.catalog_constants (
    id bigint generated by default as identity not null,
    base_price bigint null,
    sale_price bigint null,
    constraint catalog_constants_pkey primary key (id)
  ) tablespace pg_default;

-- Gold
create table
  public.gold_ledger (
    id bigint generated by default as identity not null,
    transaction_date timestamp with time zone not null default now(),
    transaction_type text null,
    transaction_id bigint null,
    gold bigint not null default '0'::bigint,
    constraint gold_ledger_pkey primary key (id),
    constraint gold_ledger_transaction_type_check check (
      (
        transaction_type = any (
          array[
            'barrel'::text,
            'potion'::text,
            'capacity'::text,
            'default'::text
          ]
        )
      )
    )
  ) tablespace pg_default;

-- Ticks
create table
  public.ticks (
    id bigint generated by default as identity not null,
    day text null,
    hour integer null,
    visits bigint[] null,
    constraint ticks_pkey primary key (id)
  ) tablespace pg_default;

create function update_potion_price()
returns trigger as $$
declare
  -- base price/sale price respectively
  bp int;
  sp int;
  hour int;
BEGIN
  select 
    base_price, sale_price into bp, sp
  from
    catalog_constants;
  
  select
    current_tick.hour into hour
  from
    current_tick;
  
  if hour >= 20 then
    update potions set price = sp;
  else
    update potions set price = bp;
  end if;

  return new;

END;
$$ language plpgsql;

create trigger dynamic_potion_price
after insert on ticks for each statement
execute function update_potion_price ();


-- Customers/Orders
create table
  public.customers (
    id bigint generated by default as identity not null,
    name text null,
    class text null,
    level integer null,
    constraint customers_pkey primary key (id)
  ) tablespace pg_default;

create table
  public.customer_to_carts (
    customer_id bigint generated by default as identity not null,
    cart_id bigint generated by default as identity not null,
    constraint customer_to_carts_pkey primary key (customer_id, cart_id),
    constraint customer_to_carts_customer_id_fkey foreign key (customer_id) references customers (id) on update cascade on delete restrict
  ) tablespace pg_default;

create table
  public.cart_items (
    id bigint generated by default as identity not null,
    potion_sku text null,
    quantity bigint not null default '0'::bigint,
    constraint cart_items_pkey primary key (id),
    constraint cart_items_potion_sku_fkey foreign key (potion_sku) references potions (sku) on update cascade on delete restrict
  ) tablespace pg_default;

create table
  public.completed_orders (
    id bigint generated by default as identity not null,
    created_at timestamp with time zone not null default now(),
    customer_id bigint not null,
    potion_sku text not null,
    quantity bigint not null,
    tick bigint not null,
    cost bigint not null,
    constraint completed_orders_pkey primary key (id),
    constraint completed_orders_customer_id_fkey foreign key (customer_id) references customers (id) on update cascade on delete restrict,
    constraint completed_orders_potion_sku_fkey foreign key (potion_sku) references potions (sku) on update cascade on delete restrict,
    constraint completed_orders_tick_fkey foreign key (tick) references ticks (id) on update cascade on delete restrict
  ) tablespace pg_default;

-------------------- Views --------------------
create view
  public.current_tick as
select
  ticks.id,
  ticks.day,
  ticks.hour
from
  ticks
order by
  ticks.id desc
limit
  1;
  
create view
  public.barrel_purchase_stats as
with
  current_gold as (
    select
      sum(gold_ledger.gold) as gold
    from
      gold_ledger
  ),
  current_ml as (
    select
      array[
        coalesce(sum(barrel_ledger.red), 0::numeric),
        coalesce(sum(barrel_ledger.green), 0::numeric),
        coalesce(sum(barrel_ledger.blue), 0::numeric),
        coalesce(sum(barrel_ledger.dark), 0::numeric)
      ] as current_ml
    from
      barrel_ledger
  ),
  max_ml as (
    select
      sum(capacity_ledger.ml) as max_ml
    from
      capacity_ledger
  )
select
  current_gold.gold,
  current_ml.current_ml,
  max_ml.max_ml
from
  current_gold
  join current_ml on 1 = 1
  join max_ml on 1 = 1;

create view
  public.bottle_plan as
with
  top_potions as (
    select
      completed_orders.potion_sku as sku,
      potions.name,
      array[
        potions.red,
        potions.green,
        potions.blue,
        potions.dark
      ] as potion_type,
      completed_orders.quantity as weight
    from
      completed_orders
      join potions on potions.sku = completed_orders.potion_sku
    where
      (
        completed_orders.tick in (
          select
            ticks.id
          from
            ticks
          where
            ticks.day = (
              (
                select
                  current_tick.day
                from
                  current_tick
              )
            )
        )
      )
    order by
      completed_orders.quantity desc
  ),
  random_potions as (
    select
      potions.sku,
      potions.name,
      array[
        potions.red,
        potions.green,
        potions.blue,
        potions.dark
      ] as potion_type,
      5 as weight
    from
      potions
    where
      not (
        potions.sku in (
          select
            top_potions.sku
          from
            top_potions
        )
      )
    order by
      (random())
  )
select
  top_potions.sku,
  top_potions.name,
  top_potions.potion_type,
  top_potions.weight
from
  top_potions
union
select
  random_potions.sku,
  random_potions.name,
  random_potions.potion_type,
  random_potions.weight
from
  random_potions
order by
  weight desc;

create view
  public.capacity_stats as
with
  total_potions as (
    select
      sum(potion_ledger.quantity) as current_potions
    from
      potion_ledger
  ),
  total_ml as (
    select
      sum(
        barrel_ledger.red + barrel_ledger.green + barrel_ledger.blue + barrel_ledger.dark
      ) as current_ml
    from
      barrel_ledger
  ),
  total_gold as (
    select
      sum(gold_ledger.gold) as gold
    from
      gold_ledger
  ),
  total_capacity as (
    select
      sum(capacity_ledger.potions) as potion_capacity,
      sum(capacity_ledger.ml) as ml_capacity
    from
      capacity_ledger
  )
select
  total_potions.current_potions,
  total_ml.current_ml,
  total_gold.gold,
  total_capacity.potion_capacity,
  total_capacity.ml_capacity
from
  total_potions
  join total_ml on 1 = 1
  join total_gold on 1 = 1
  join total_capacity on 1 = 1;

create view
  public.catalog as
with
  top_potions as (
    select
      co.potion_sku as sku,
      potions.name,
      array[
        potions.red,
        potions.green,
        potions.blue,
        potions.dark
      ] as potion_type,
      sum(co.quantity) as weight,
      sum(potion_ledger.quantity) as quantity,
      potions.price
    from
      completed_orders co
      join potions on potions.sku = co.potion_sku
      join potion_ledger on potion_ledger.potion_sku = co.potion_sku
    where
      (
        co.tick in (
          select
            ticks.id
          from
            ticks
          where
            ticks.day = (
              (
                select
                  current_tick.day
                from
                  current_tick
              )
            )
        )
      )
    group by
      co.potion_sku,
      potions.name,
      potions.red,
      potions.green,
      potions.blue,
      potions.dark,
      potions.price
    having
      sum(potion_ledger.quantity) > 0::numeric
  ),
  random_potions as (
    select
      potions.sku,
      potions.name,
      array[
        potions.red,
        potions.green,
        potions.blue,
        potions.dark
      ] as potion_type,
      sum(potion_ledger.quantity) as quantity,
      potions.price
    from
      potions
      join potion_ledger on potion_ledger.potion_sku = potions.sku
    where
      not (
        potions.sku in (
          select
            top_potions.sku
          from
            top_potions
        )
      )
    group by
      potions.sku,
      potions.name,
      potions.red,
      potions.green,
      potions.blue,
      potions.dark,
      potions.price
    having
      sum(potion_ledger.quantity) > 0::numeric
    order by
      (random())
  )
select
  top_potions.sku,
  top_potions.name,
  top_potions.potion_type,
  top_potions.weight,
  top_potions.quantity,
  top_potions.price
from
  top_potions
union
select
  random_potions.sku,
  random_potions.name,
  random_potions.potion_type,
  5 as weight,
  random_potions.quantity,
  random_potions.price
from
  random_potions
limit
  6;

create view
  public.inventory_stats as
with
  total_potions as (
    select
      coalesce(sum(potion_ledger.quantity), 0::numeric) as total_potions
    from
      potion_ledger
  ),
  total_ml as (
    select
      coalesce(
        sum(
          barrel_ledger.red + barrel_ledger.green + barrel_ledger.blue + barrel_ledger.dark
        ),
        0::numeric
      ) as total_ml
    from
      barrel_ledger
  ),
  total_gold as (
    select
      coalesce(sum(gold_ledger.gold), 0::numeric) as total_gold
    from
      gold_ledger
  )
select
  total_potions.total_potions,
  total_ml.total_ml,
  total_gold.total_gold
from
  total_potions
  join total_ml on 1 = 1
  join total_gold on 1 = 1;

create view
  public.potion_plan_stats as
with
  current_ml as (
    select
      array[
        coalesce(sum(barrel_ledger.red), 0::numeric),
        coalesce(sum(barrel_ledger.green), 0::numeric),
        coalesce(sum(barrel_ledger.blue), 0::numeric),
        coalesce(sum(barrel_ledger.dark), 0::numeric)
      ] as ml
    from
      barrel_ledger
  ),
  max_potions as (
    select
      sum(capacity_ledger.potions) as max_potions
    from
      capacity_ledger
  ),
  current_potions as (
    select
      coalesce(sum(potion_ledger.quantity), 0::numeric) as current_potions
    from
      potion_ledger
  )
select
  current_ml.ml,
  max_potions.max_potions,
  current_potions.current_potions,
  current_tick.hour
from
  current_ml
  join max_potions on 1 = 1
  join current_potions on 1 = 1
  join current_tick on 1 = 1;

create view
  public.search_orders as
select
  co.id as line_item_id,
  customers.name as customer_name,
  co.quantity,
  potions.name as item_sku,
  co.cost as line_item_total,
  current_time as "timestamp"
from
  completed_orders co
  join customers on co.customer_id = customers.id
  join potions on potions.sku = co.potion_sku;

-------------------- Functions --------------------
create function check_customer_exists(in_name text, in_class text, in_level integer)
returns boolean as $$
DECLARE
  exists boolean := false;
begin
  
  select exists (
    select 1
    from customers
    where
      name = in_name
      and
      class = in_class
      and
      level = in_level
  ) into exists;

  return exists;
end;
$$ language plpgsql;

create function reset_shop()
returns void as $$
BEGIN
  truncate barrel_ledger;
  truncate capacity_ledger;
  truncate gold_ledger;
  truncate potion_ledger;

  -- Insert values into necessary ledgers
  insert into gold_ledger
  (id, transaction_type, gold) values (0, 'default', 100);

  insert into capacity_ledger
  (id, potions, ml) values (0, 50, 10000);
END;
$$ language plpgsql;